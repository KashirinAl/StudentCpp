# Лабораторная 1-4. Функции
Изучаемые темы: функция, передача параметров в функция, возрат результата работы функции, прототип ф-ции
### Теория
[Функции](https://github.com/StriderAJR/StudentCpp/wiki/Функции)


## Приступая к работе...
1. Что такое ф-ция, прототип ф-ции, заголовок ф-ции?
1. Синтаксис заголовка ф-ции.
1. Для чего нужны прототипы ф-ций
1. Как в ф-ции задаются параметры
1. Что такое тип возвращаемого значения
1. Что такое return
1. Когда завершается выполнение ф-ции

## Задание
TODO

### Пример
```c++
// Функция - это именованный кусок кода, 
// который можно вызывать для выполнения неограниченное кол-во раз
// Основная задача ф-ций - сделать код более компактным и читаемым

// Пример простейшей ф-ции
int add(int a, int b) // <-- Заголовок ф-ции
{ // <-- Начало тела ф-ции

    // Тут может быть любой код, который нужно выполнить

    return a + b; // Возвращаем результат работы функции
} // <-- Конец тела ф-ции

// Заголовок ф-ции обязательно должен состоять из следующий элементов:

// ТВЗ ИМЯ_ФУНКЦИИ(СПИСОК_ПАРАМЕТРОВ)

// ТИП ВОЗВРАЩАЕМОГО ЗНАЧЕНИЯ (ТВЗ)
// Это тип данных результата работы ф-ции. Именно результат останется в коде в месте вызова вашей ф-ции
// Если ф-ция не будет иметь результат (просто что-то делает и все), тогда тип возвращаемого значения будет void - отсутствие типа

// ИМЯ ФУНКЦИИ
// всегда должно содержать глаголы и по имени ф-ции должно быть легко понятно, что она делает. 
// Хорошие примеры имен ф-ций: readFromFile, writeToFile, getVectorLength, multiplyMatrix, add
// Примеры плохих имен функций: func1, foo, boo, getResult, do, blablabla

// СПИСОК ПАРАМЕТРОВ
// Параметры перечисляются в ф-ции через запятую. Параметр - это локальная переменная для функции, а значит вы объявляете переменные.
// Синтаксис будет соответствующий. int param1, double param2 и т.д.

// Еще немного примеров ф-ций:

void writeToFile(char* str)
{
    // ...
}

double devide(int a, double b, float c)
{
    return a / b / c;

    cout << "^_^"; // Этот код уже не будет выполнен
    // После команды return ф-ция возвращает результат своей работы и завершает выполнение сразу
}

void consoleRead(char* buff, int num)
{
    cin.getline(buff, num);
}

int main() 
{
    double a = devide(10, 3.7, 1.2);
    // ^^^
    // Что будет происходить: 
    // 1. Вызовется ф-ция, параметры (локальные переменные ф-ции) проинициализируются соответствующими значениями 
    // (a = 10, b = 3.7, c = 1.2)
    // Обратите внимание, что переменная a в ф-ции main и переменная a - в ф-ции devide - 
    // разные локальные переменные!
    // ВНИМАНИЕ!!! 
    // Каждая существует только внутри своего блока кода. И они никак не перемекаются, это разные ячейки в памяти.
    // 
    // 2. Ф-ция devide делает свое дело (причем, что она делает нас в ф-ции main вооще не волнует - 
    // это личное дело самой ф-ции)
    //
    // 3. Как ф-ция выполнится, вместе всей конструкции "devide(10, 3.7, 1.2)" 
    // подставится итоговый результат работы ф-ции.
    // Будет что-то вроде
    // double a = результат;

    // И вызывать функцию мы можем до посинения:
    
    while (a > 0)
    {
        cout << a << endl;
        int p1; double p2; float p3;
        cin >> p1 >> p2 >> p3;
        a = devide(p1, p2, p3);
    }

    return 0;
}

// А теперь рассмотрим, когда функции каскадно вызывают друг друга

void ChildFunction()
{
    cout << "ChildFunction called" << endl;
}

void ParentFunction()
{
    cout << "ParentFunction called" << endl;
    // LastFunction(); // <-- Попробуйте раскомментировать эту строчку

    // У вас будет ошибка, смысл которой сводится к тому, что компилятор не знает такую ф-цию LastFunction
    // Кажется, что это бред, потому что вон же она чуть ниже, однако это не бред:
    // компилятор С++ работает сверху вниз - все, что используется должно быть объявлено выше того момента, 
    // когда вы это используете.
    // Поэтому компилятор действительно на момент вызова ф-ции LastFunction ее еще не встретил и не знает, 
    // что это такое и как себя с ней вести.

    // Думаете проблема решается просто? Нужно просто перенести LastFunction повыше? Ну попробуйте
    // И увидите, что тут специально использовано несколько перекрестных ф-ций, которые используются друг другом.
    // В лучшем случае вам придется долго играть в пятнашки, чтобы правильно разместить перекрестные ф-ции, 
    // и чтобы они "видели" друг друга.
    // Но программисты люди ленивые - играть в пятнашки слишком долго и неэффективно

    // Пробелма решается с использованием "прототипов" функций (см. ниже)
}

void SemiFunction()
{
    cout << "SemiFunction called" << endl;

    ParentFunction();
}

void LastFunction()
{
    cout << "LastFunction called" << endl;

    SemiFunction();
}

// ИСПОЛЬЗОВАНИЕ ПРОТОТИПОВ

void AnotherChildFunction();  // Это называется прототипов ф-ции. 
                              // Прототип - синтаксическая запись заголовка ф-ции без тела
void AnotherParentFunction(); // После заголовка функции сразу же идет ";" 
                              // блок кода ф-ции не начинается, его просто нет
void AnotherSemiFunction();   // Прототип ф-ции дает понять компилятору, 
                              // что где-то там когда-нибудь обязательно встретиться
void AnotherLastFunction();   // ф-ция в своем нормальном виде, 
                              // но вот прямо сейчас всю ф-цию мы тебе не покажем, но имей в виде, что она есть.

// После такого "диалога" компилятор успокаивается, 
// он нам верит до поры до времени и если встретит использования ф-ции,
// описанной с помощью прототипа, он это проглотит и уже не будет пугаться "Ой, а чёй-то такое?!?!"
// Но имейте в виду, если есть прототип ф-ции, но до конца модуля самой ф-ции не встретится, 
// то компилятор все равно поднимет панику:
// "Ты мне обещал! Обещал, что покажешь всю ф-цию, а ее нет!!!! :'''((("

void AnotherChildFunction()
{
    cout << "ChildFunction called" << endl;
}

void AnotherParentFunction()
{
    cout << "ParentFunction called" << endl;
    AnotherLastFunction();
}

void AnotherSemiFunction()
{
    cout << "SemiFunction called" << endl;

    ParentFunction();
}

void AnotherLastFunction()
{
    cout << "LastFunction called" << endl;

    SemiFunction();
}
```
