// Рассматриваемые темы:
// Массив, статический массив

#pragma once
#include <iostream>
using namespace  std;

namespace StaticArray
{
   int main()
   {
      /*
       * Массив - это именнованная последовательность элементов в памяти.
       * Особенностью массива является, что элементы хранятся в памяти друг за другом
       * причем подряд.
       * 
       * Доступ до элементов идет по индексу элемента.
       * Индексация всегда начинается с нуля.
       * 
       *       0      1      2      3      4
       *    |------|------|------|------|------|
       *    |  12  |  60  |  25  |  5   |  19  |
       *    |------|------|------|------|------|
       *    
       * Это иллюстрация ячеек памяти массива на 5 элементов.
       * 
       * Массив может быть объявлен статически и динамически.
       * 1. При статическом объявлении память под массив выделяется в стеке,
       * массив является локальной переменной и будет уничтожен по правилам
       * локальных переменных.
       * 2. При динамическом объявлении память выделяется в куче программы - 
       * ее еще называют динамической памятью. Управление ею лежит полностью
       * на совести самого программиста. Доступ до массива осуществляется
       * через указатель.
       * 
       * Сейчас речь пойдет про СТАТИЧЕСКИЙ МАССИВ.
       * Объявить и проинициализировать такой массив можно следюущим образом:
       */

      int array1[5];
      /*
       * int - тип данных элементов массива
       * Это будет массив, хранящий целые числа
       * Тип данных элементов может быть любой
       * array1 - имя переменной. Вы сами его выбираете
       * [n], где n - кол-во элементов в массиве
       * Причем n должно быть константой так или иначе
      */

      int n = 10;
      const int m = 10;
      int array01[m];
      int array02[10];
      // int array03[n]; // А вот так не получится
      /*
       * Не получится, потому что компилятор не может быть на момент исполнения
       * предсказать, какое число будет вместо n. А значит и выделить память в стеке
       * небезопасно, а значит... Не пошел бы программист лесом. :)
      */

      // Обращение к ячейке памяти происходит с помощью оператора []
      // Как параметр этот параметр принимает
      // СМЕЩЕНИЕ относительно начала массива
      array1[0] = 12;
      array1[1] = 60;
      array1[2] = 25;
      array1[3] = 5;
      array1[4] = 19;

      /*
       * Догадливые уже могли понять:
       * имя массива является адресом начала массива в памяти
       * 
       *       0      1      2      3      4
       *    |------|------|------|------|------|
       *    |  12  |  60  |  25  |  5   |  19  |
       *    |------|------|------|------|------|
       *       ^
       *       |
       *     array1
       *     
       * И переменная array1 хранит именно АДРЕС самой первой ячейки массива
       * (см. раздел указатели, в котором пояснено, что, например, 1 число типа int
       * занимает не 1 ячейку памяти, а 4, потому что 1 ячейка = 1 байт)
       * 
       *          Байты 0 элемента            Байты 1 элемента            .....
       *    |---------------------------|---------------------------|---- и т.д.    
       *    |                           |                           |
       *    |------|------|------|------|------|------|------|------|
       *    |  хх  |  хх  |  хх  |  хх  |  хх  |  хх  |  хх  |  хх  |     ......
       *    |------|------|------|------|------|------|------|------|
       *       ^
       *       |
       *     array1
       * 
       * array1 - локальная переменная. А значит хранится в стеке.
       * array1 хранит адрес ячейки в стеке.
       */

      cout << "array1 = " << array1 << endl;

      // Естественно, что массивом можно управлять и с помощью цикла
      for (int i = 0; i < 5; i++) cout << "array1[" << i << "] = " << array1[i] << endl;

      // Если элементы массива извесстны заранее, то объявление и инициализацию можно объединить
      float array2[3] = { 1.2, 3.6, 20.5 };
      // А еще можно так
      double array3[] = { 1, 2, 3 };

      /*
       * Как и любая локальная переменная статический массив будет уничтожен
       * по завершению блока кода, в котором был объявлен.
       */

      /*
       * А теперь задумаемся вот над каким вопросом:
       * если имя массива - это адрес самой первой ячейки в самом массиве,
       * иными словами:
       * 
       * имя массива - это указатель на начало массива.
       * 
       * Но как же оператор [] по индексу элемента извлекает данные из массива?
       * 
       * Если вы хорошо усвоили тему указателей и операций над указателями,
       * то вы легко найдете ответ на этот вопрос.
       * 
       * Допустим, нам нужен самый первый элемент массива. 
       * Сам указатель массива уже хранит адрес этого элемента, нам достаточно разыменовать указатель
       * на массив и мы получим искомый элемент
       */

      cout << "array1[0] = " <<*array1 << endl;

      /*
       * Теперь нам нужен следующий, второй элемент. Он лежит сразу же за первым,
       * помня о масштабировании адресов, мы знаем, что достаточно увеличить указатель
       * на единицу, чтобы получить адрес искомого элемента, а затем разыменовать его
       */

      cout << "array1[1] = " << *(array1 + 1) << endl;

      /*
       * Заметили? Индекс, который передается в оператор [] - это СМЕЩЕНИЕ элемента
       * относительно начала массива! Т.е. индексация с нуля взялась не на пустом месте,
       * это обусловлено косвенной адресацией через указатели!
       * 
       * Вау!!! Магия. ^_^
       * 
       * Поэтому на самом деле за строчкой 
       * 
       * cout << "array1[0] = " <<*array1 << endl;
       * скрывается
       * cout << "array1[0] = " <<*(array1 + 0) << endl;
       * 
       * Просто ноль мы, как люди, обычно не пишем.
       * 
       * Так что вывести на экран можно двумя способами:
       */

      for (int i = 0; i < 5; i++) cout << "array1[" << i << "] = " << array1[i] << endl;
      // или
      for (int i = 0; i < 5; i++) cout << "array1[" << i << "] = " << *(array1 + i) << endl;

      /*
       * Так что оператор [] это опять же пресловутый синтаксический "сахар" для программиста,
       * и этот оператор просто прибавляет к адресу начала массива смещение и разыменовывает полученный указатель.
       */

      /*
       * Естественно, никто не мешает использовать полную запись доступа до элемента массива не только
       * для чтения элемента из массива, но и для записи.
       */

      *(array1 + 2) = 2;
      cout << array1[2] << endl;

      return 0;
   }
}
